import fs from 'fs';
import path from "node:path";
import c from "ansi-colors";

const lineEnding = '\n';
const directories = [__dirname + '/../test/'];
const outputLocation = __dirname + '/../test/';
const outputName = 'domain.pot';
const generatorVersion = '0.0.1';
const potHeader = `# Generated by Freave POT generator ${generatorVersion}\n` +
  '#\n' +
  '#, fuzzy\n' +
  'msgid ""\n' +
  'msgstr ""\n' +
  '"Project-Id-Version: freaveflex \\n"\n' +
  '"Report-Msgid-Bugs-To: Freave \\n"\n' +
  '"Last-Translator: Freave \\n"\n' +
  '"Language-Team: Freave \\n"\n' +
  '"MIME-Version: 1.0 \\n"\n' +
  '"Content-Type: text/plain; charset=UTF-8 \\n"\n' +
  '"Content-Transfer-Encoding: 8bit \\n"\n' +
  '"POT-Creation-Date: ' + new Date().toISOString() + ' \\n"\n' +
  '"PO-Revision-Date: ' + new Date().toISOString() + ' \\n"\n' +
  '"X-Generator: Freave POT generator 1.0 \\n"\n';


const walk = (dir: string, done: Function) => {
  let results: string[] = [];

  fs.readdir(dir, (err, list) => {
    if (err) return done(err);

    let pending = list.length;
    if (!pending) return done(null, results);

    list.forEach((file) => {
      file = path.resolve(dir, file);

      fs.stat(file, (err, stat) => {
        if (stat && stat.isDirectory()) {

          walk(file, (err: NodeJS.ErrnoException | null, res: any) => {
            results = results.concat(res);
            if (!--pending) done(null, results);
          });

        } else {

          results.push(file);
          if (!--pending) done(null, results);

        }
      });

    });
  });
};

const walkMultiple = (dirs: string[], done: any) => {
  let results: any[] = [];

  let pending = dirs.length;

  if (!pending) return done(null, results);

  dirs.forEach((dir: string) => {
    walk(dir, (err: any, res: any) => {
      results = results.concat(res);
      if (!--pending) done(null, results);
    });
  });
}

const getMatches = (files: string[]) => {

  let results: any[] = [];

  for (let file of files) {

    let content = fs.readFileSync(file, 'utf8');

    let formattedMatches = [];
    let matches = content.match(/_x\(.*?\)/gm);
    if (matches) {

      for (let match of matches) {
        let lineNumber = content.substring(0, content.indexOf(match)).split(lineEnding).length;
        let splitMatch = match.match(/_x\(\s*['"](.*?)['"]\s*,\s*['"](.*?)['"]\s*,\s*['"](.*?)['"]\s*\)/);

        if (splitMatch) {

          let formattedMatch = {
            text: splitMatch[1],
            context: splitMatch[2],
            domain: splitMatch[3]
          }

          formattedMatches.push({'filename': file, 'linenumber': lineNumber, 'match': formattedMatch});
        }

      }

      results = results.concat(formattedMatches);
    }

  }

  return results;

}

export const createPot = () => {

  console.log(c.black.bgGreen(" Freave POT generator " + generatorVersion + " "));
  console.log('\x1b[32m%s\x1b[0m', "Searching in the following directories: ");

  for (let dir of directories) {
    console.log('\x1b[32m%s\x1b[0m', dir);
  }

  walkMultiple(directories, (err: any, results: string[]) => {
    if (err) throw err;

    // filter out the files ending in .pot
    let filteredResults = results.filter((result: string) => {
      return !result.match(/.pot$/);
    });

    console.log('\x1b[32m%s\x1b[0m', "Searching " + filteredResults.length + " files...");

    let allMatches = getMatches(filteredResults);

    console.log('\x1b[42m\x1b[30m', 'Found ' + allMatches.length + ' matches.','\x1b[0m');

    let potContent = '';

    for (let singleMatch of allMatches) {
      potContent += '\n\n# ' + singleMatch.filename + ':' + singleMatch.linenumber + '\n' +
        'msgctxt "' + singleMatch.match.context + '"\n' +
        'msgid "' + singleMatch.match.text + '"\n' +
        'msgstr ""';
    }

    let potFile = potHeader + potContent;

    fs.writeFileSync(outputLocation + outputName, potFile);
    console.log('\x1b[32m%s\x1b[0m', '\nPOT file created in ' + outputLocation + outputName);
  });

}
